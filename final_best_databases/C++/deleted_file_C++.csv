Unnamed: 0,text,code,task_id,modified
6,This is  a function to find all words which are at least 4 characters long in a string by using regex.,"```
#include <iostream>
#include <regex>
#include <string>
#include <vector>

std::vector<std::string> find_char_long(const std::string& text) {
    std::regex word_regex(R""(\b\w{4,}\b)"");
    std::sregex_iterator iter(text.begin(), text.end(), word_regex);
    std::sregex_iterator end;

    std::vector<std::string> results;
    while (iter != end) {
        results.push_back(iter->str());
        ++iter;
    }
    return results;
}
```",7,"[assert((find_char_long(""Please move back to stream"") == std::vector<std::string>{""Please"", ""move"", ""back"", ""stream""}));, assert((find_char_long(""Jing Eco and Tech"") == std::vector<std::string>{""Jing"", ""Tech""}));, assert((find_char_long(""Jhingai wulu road Zone 3"") == std::vector<std::string>{""Jhingai"", ""wulu"", ""road"", ""Zone""}));]"
9,This is  a function to get the n smallest items from a dataset.,"```
#include <vector>
#include <queue>
#include <algorithm>

std::vector<int> small_nnum(const std::vector<int>& list1, int n) {
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
    for (int num : list1) {
        minHeap.push(num);
    }
    
    std::vector<int> smallest;
    for (int i = 0; i < n && !minHeap.empty(); ++i) {
        smallest.push_back(minHeap.top());
        minHeap.pop();
    }
    
    return smallest;
}
```",10,"[assert((small_nnum({ 10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100 }, 2) == std::vector<int>{10, 20}));, assert((small_nnum({ 10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100 }, 5) == std::vector<int>{10, 20, 20, 40, 50}));, assert((small_nnum({ 10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100 }, 3) == std::vector<int>{10, 20, 20}));]"
50,This is  a function to print check if the triangle is equilateral or not.,"```
bool check_equilateral(int x, int y, int z) {
    if (x == y && y == z) {
        return true;
    } else {
        return false;
    }
}
```",51,"[assert(check_equilateral(6, 8, 12) == false);, assert(check_equilateral(6, 6, 12) == false);, assert(check_equilateral(6, 6, 6) == true);]"
52,This is  a C++ function to check whether the first and last characters of a given string are equal or not.,"```
#include <string>

std::string check_Equality(const std::string& str) {
    if (str[0] == str[str.length() - 1]) {
        return ""Equal"";
    } else {
        return ""Not Equal"";
    }
}
```",53,"[assert(check_Equality(""abcda"") == ""Equal"");, assert(check_Equality(""ab"") == ""Not Equal"");, assert(check_Equality(""mad"") == ""Not Equal"");]"
58,This is  a function to find the nth octagonal number.,"```
int is_octagonal(int n) {
    return 3 * n * n - 2 * n;
}
```",59,"[assert(is_octagonal(5) == 65);, assert(is_octagonal(10) == 280);, assert(is_octagonal(15) == 645);]"
70,This is  a function to sort a list of elements using comb sort.,"```
#include <vector>

std::vector<int> comb_sort(std::vector<int> nums) {
    double shrink_fact = 1.3;
    int gaps = nums.size();
    bool swapped = true;
    int i = 0;
    while (gaps > 1 || swapped) {
        gaps = static_cast<int>(gaps / shrink_fact);
        swapped = false;
        i = 0;
        while (gaps + i < nums.size()) {
            if (nums[i] > nums[i + gaps]) {
                std::swap(nums[i], nums[i + gaps]);
                swapped = true;
            }
            i++;
        }
    }
    return nums;
}
```",71,"[assert(comb_sort({5, 15, 37, 25, 79}) == std::vector<int>({5, 15, 25, 37, 79}));, assert(comb_sort({41, 32, 15, 19, 22}) == std::vector<int>({15, 19, 22, 32, 41}));, assert(comb_sort({99, 15, 13, 47}) == std::vector<int>({13, 15, 47, 99}));]"
72,This is  a function to split the given string with multiple delimiters by using regex.,"```
#include <string>
#include <vector>
#include <sstream>
#include <regex>

std::vector<std::string> multiple_split(const std::string& text) {
    std::regex reg("";/ |, |\\*|\\n"");
    std::sregex_token_iterator it(text.begin(), text.end(), reg, -1);
    std::sregex_token_iterator reg_end;
    return std::vector<std::string>(it, reg_end);
}
```",73,"[assert((multiple_split(""Forces of the \\ndarkness*are coming into the play."") == std::vector<std::string>{""Forces of the "", ""darkness"", ""are coming into the play.""}));, assert((multiple_split(""Mi Box runs on the \\n Latest android*which has google assistance and chromecast."") == std::vector<std::string>{""Mi Box runs on the "", "" Latest android"", ""which has google assistance and chromecast.""}));, assert((multiple_split(""Certain services\\nare subjected to change*over the seperate subscriptions."") == std::vector<std::string>{""Certain services"", ""are subjected to change"", ""over the seperate subscriptions.""}));]"
80,This is  a function to zip the two given tuples.,"```
#include <cassert>
#include <tuple>
#include <vector>
#include <iostream>

// Function to zip two tuples into a vector of tuples
std::vector<std::tuple<int, int>> zip_tuples(const std::tuple<int, int, int, int, int, int>& a, const std::tuple<int, int, int>& b) {
    std::vector<std::tuple<int, int>> result;

    // Manually extract elements from tuple a and b
    result.emplace_back(std::make_tuple(std::get<0>(a), std::get<0>(b)));
    result.emplace_back(std::make_tuple(std::get<1>(a), std::get<1>(b)));
    result.emplace_back(std::make_tuple(std::get<2>(a), std::get<2>(b)));
    result.emplace_back(std::make_tuple(std::get<3>(a), std::get<0>(b))); // Wrapping around b
    result.emplace_back(std::make_tuple(std::get<4>(a), std::get<1>(b))); // Wrapping around b
    result.emplace_back(std::make_tuple(std::get<5>(a), std::get<2>(b))); // Wrapping around b

    return result;
}

// Comparison function for two vectors of tuples
bool compare_vectors(const std::vector<std::tuple<int, int>>& v1, const std::vector<std::tuple<int, int>>& v2) {
    return v1 == v2;
}```",81,"[assert(compare_vectors(zip_tuples(std::make_tuple(7, 8, 4, 5, 9, 10), std::make_tuple(1, 5, 6)), std::vector<std::tuple<int, int>>{{7, 1}, {8, 5}, {4, 6}, {5, 1}, {9, 5}, {10, 6}}));, assert(compare_vectors(zip_tuples(std::make_tuple(8, 9, 5, 6, 10, 11), std::make_tuple(2, 6, 7)), std::vector<std::tuple<int, int>>{{8, 2}, {9, 6}, {5, 7}, {6, 2}, {10, 6}, {11, 7}}));, assert(compare_vectors(zip_tuples(std::make_tuple(9, 10, 6, 7, 11, 12), std::make_tuple(3, 7, 8)), std::vector<std::tuple<int, int>>{{9, 3}, {10, 7}, {6, 8}, {7, 3}, {11, 7}, {12, 8}}));]"
81,This is  a function to find the volume of a sphere.,"```
#include <cassert>
#include <cmath>

double volume_sphere(double radius) {
    return (4.0 / 3.0) * M_PI * std::pow(radius, 3);
}```",82,"[assert(volume_sphere(10) == 4188.790204786391);, assert(volume_sphere(25) == 65449.84694978735);, assert(volume_sphere(20) == 33510.32163829113);]"
88,This is  a function to find the closest smaller number than n.,"```
#include <utility>

std::pair<int, int> closest_num(int N) {
    return std::make_pair(N - 1, 0);
}
```",89,"[assert(closest_num(11).first == 10);, assert(closest_num(7).first == 6);, assert(closest_num(12).first == 11);]"
92,This is  a function to calculate the value of 'a' to the power 'b'.,"```
int power(int a, int b) {
    if (b == 0) {
        return 1;
    } else if (a == 0) {
        return 0;
    } else if (b == 1) {
        return a;
    } else {
        return a * power(a, b - 1);
    }
}
```",93,"[assert(power(3, 4) == 81);, assert(power(2, 3) == 8);, assert(power(5, 5) == 3125);]"
95,This is  a C++ function to find the number of divisors of a given integer.,"```
#include <vector>

std::pair<int, int> divisor(int n) {
    int x = 0;
    for (int i = 1; i <= n; ++i) {
        if (n % i == 0) {
            x++;
        }
    }
    return {x, x}; // returning a pair as there's no second value in original code
}
```",96,"[assert(divisor(15).first== 4);, assert(divisor(12).first == 6);, assert(divisor(9).first == 3);]"
125,This is  a C++ function to find the sum of common divisors of two given numbers.,"```
#include <iostream>
#include <algorithm>
#include <cassert>

int sum(int a, int b) {
    int sum = 0;
    for (int i = 1; i < std::min(a, b); ++i) {
        if (a % i == 0 && b % i == 0) {
            sum += i;
        }
    }
    return sum; // Return only the sum
}```",126,"[assert(sum(10, 15) == 6);  // Sum of common divisors: 1, 2, 5, assert(sum(100, 150) == 93);  // Sum of common divisors: 1, 2, 5, 10, 25, 50, assert(sum(4, 6) == 3);  // Sum of common divisors: 1, 2]"
128,This is  a function to calculate magic square.,"```
#include <vector>
#include <numeric>
#include <set>

bool magic_square_test(const std::vector<std::vector<int>>& my_matrix) {
    int iSize = my_matrix[0].size();
    std::vector<int> sum_list;

    for (const auto& lines : my_matrix) {
        sum_list.push_back(std::accumulate(lines.begin(), lines.end(), 0));
    }

    for (int col = 0; col < iSize; ++col) {
        int col_sum = 0;
        for (int row = 0; row < my_matrix.size(); ++row) {
            col_sum += my_matrix[row][col];
        }
        sum_list.push_back(col_sum);
    }

    int result1 = 0;
    for (int i = 0; i < iSize; ++i) {
        result1 += my_matrix[i][i];
    }
    sum_list.push_back(result1);

    int result2 = 0;
    for (int i = iSize - 1; i >= 0; --i) {
        result2 += my_matrix[i][i];
    }
    sum_list.push_back(result2);

    return std::set<int>(sum_list.begin(), sum_list.end()).size() <= 1;
}
```",129,"[assert(magic_square_test({{7, 12, 1, 14}, {2, 13, 8, 11}, {16, 3, 10, 5}, {9, 6, 15, 4}}) == true);, assert(magic_square_test({{2, 7, 6}, {9, 5, 1}, {4, 3, 8}}) == true);, assert(magic_square_test({{2, 7, 6}, {9, 5, 1}, {4, 3, 7}}) == false);]"
149,This is  a C++ function to find whether the given number is present in the infinite sequence or not.,"```
bool does_Contain_B(int a, int b, int c) { 
    if (a == b) { 
        return true; 
    } 
    if ((b - a) * c > 0 && (b - a) % c == 0) { 
        return true; 
    } 
    return false; 
}
```",150,"[assert(does_Contain_B(1, 7, 3) == true);, assert(does_Contain_B(1, -3, 5) == false);, assert(does_Contain_B(3, 2, 5) == false);]"
170,This is  a function to find the perimeter of a pentagon.,"```

#include <iostream>

double perimeter_pentagon(double a) {
    double perimeter = 5 * a;
    return perimeter;
}```",171,"[assert(perimeter_pentagon(5) == 25);, assert(perimeter_pentagon(10) == 50);, assert(perimeter_pentagon(15) == 75);]"
188,This is  a C++ function to find the first missing positive number.,"```
#include <vector>
using namespace std;

int first_Missing_Positive(vector<int>& arr, int n) {
    int ptr = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] == 1) {
            ptr = 1;
            break;
        }
    }
    if (ptr == 0) {
        return 1;
    }
    for (int i = 0; i < n; i++) {
        if (arr[i] <= 0 || arr[i] > n) {
            arr[i] = 1;
        }
    }
    for (int i = 0; i < n; i++) {
        arr[(arr[i] - 1) % n] += n;
    }
    for (int i = 0; i < n; i++) {
        if (arr[i] <= n) {
            return i + 1;
        }
    }
    return n + 1;
}
```",189,"[assert(first_Missing_Positive({ 1, 2, 3, -1, 5 }, 5) == 4);, assert(first_Missing_Positive({ 0, -1, -2, 1, 5, 8 }, 6) == 2);, assert(first_Missing_Positive({ 0, 1, 2, 5, -8 }, 5) == 3);]"
196,This is  a function to perform the exponentiation of the given two tuples.,"```
#include <iostream>
#include <vector>
#include <cmath>
#include <cassert>

std::vector<int> findExponentio(const std::vector<int>& testTup1, const std::vector<int>& testTup2) {
    std::vector<int> res(testTup1.size());
    for (size_t i = 0; i < testTup1.size(); ++i) {
        res[i] = static_cast<int>(std::pow(testTup1[i], testTup2[i])); // Exponentiation and cast to int
    }
    return res;
}```",197,"[assert((findExponentio({ 10, 4, 5, 6 }, { 5, 6, 7, 5 }) == std::vector<int>{100000, 4096, 78125, 7776}));, assert((findExponentio({ 11, 5, 6, 7 }, { 6, 7, 8, 6 }) == std::vector<int>{1771561, 78125, 1679616, 117649}));, assert((findExponentio({ 12, 6, 7, 8 }, { 7, 8, 9, 7 }) == std::vector<int>{35831808, 1679616, 40353607, 2097152}));]"
203,This is  a C++ function to count the occurrence of a given character in a string.,"```
#include <string>

std::pair<int, int> count(const std::string& s, char c) {
    int res = 0;
    for (size_t i = 0; i < s.length(); ++i) {
        if (s[i] == c) {
            res = res + 1;
        }
    }
    return {res, 0}; // Returning 0 as the second value since it's not defined in C++ code
}
```",204,"[assert(count(""abcc"", \c\).first == 2);, assert(count(""ababca"", \a\).first == 3);, assert(count(""mnmm0pm"", \m\).first == 4);]"
212,This is  a function to perform the concatenation of two string tuples.,"```
#include <iostream>
#include <vector>
#include <cassert>

std::vector<std::string> concatenateStrings(const std::vector<std::string>& testTup1, const std::vector<std::string>& testTup2) {
    std::vector<std::string> res(testTup1.size());
    for (size_t i = 0; i < testTup1.size(); ++i) {
        res[i] = testTup1[i] + testTup2[i];  // Concatenate the strings
    }
    return res;
}```",213,"[assert((concatenateStrings({ ""Manjeet"", ""Nikhil"", ""Akshat"" }, { "" Singh"", "" Meherwal"", "" Garg"" }) == std::vector<std::string>{""Manjeet Singh"", ""Nikhil Meherwal"", ""Akshat Garg""}));, assert((concatenateStrings({ ""Shaik"", ""Ayesha"", ""Sanya"" }, { "" Dawood"", "" Begum"", "" Singh"" }) == std::vector<std::string>{""Shaik Dawood"", ""Ayesha Begum"", ""Sanya Singh""}));, assert((concatenateStrings({ ""Harpreet"", ""Priyanka"", ""Muskan"" }, { ""Kour"", "" Agarwal"", ""Sethi"" }) == std::vector<std::string>{""HarpreetKour"", ""Priyanka Agarwal"", ""MuskanSethi""}));]"
217,This is  a C++ function to find the minimum operations required to make two numbers equal.,"```
#include <iostream>
#include <algorithm>
#include <numeric>
#include <cassert>
#include <cmath>

std::pair<int, int> min_Operations(int A, int B) {
    if (A > B) {
        std::swap(A, B);
    }

    int gcd_value = std::gcd(A, B);
    B = B / gcd_value;  // Divide B by the greatest common divisor
    int operations = B - 1;  // The number of operations needed
    return { operations, 0 };   // Return the number of operations and 0 as the second part of the pair
}
```",218,"[assert(min_Operations(2, 4).first == 1);  // Expected result for 2, 4, assert(min_Operations(4, 10).first == 4); // Expected result for 4, 10, assert(min_Operations(1, 4).first == 3);  // Expected result for 1, 4]"
220,This is  a C++ function to find the first even number in a given list of numbers.,"```
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int firstEven(const std::vector<int>& nums) {
    auto it = std::find_if(nums.begin(), nums.end(), [](int el) { return el % 2 == 0; });
    return (it != nums.end()) ? *it : -1;
}```",221,"[assert(firstEven({ 1, 3, 5, 7, 4, 1, 6, 8 }) == 4);, assert(firstEven({ 2, 3, 4 }) == 2);, assert(firstEven({ 5, 6, 7 }) == 6);]"
226,This is  a function to find minimum of three numbers.,"```
#include <iostream>
#include <cassert>

int min_of_three(int a, int b, int c) {
    if ((a <= b) && (a <= c)) {
        return a;
    }
    else if ((b <= a) && (b <= c)) {
        return b;
    }
    else {
        return c;
    }
}```",227,"[assert(min_of_three(10, 20, 0) == 0);, assert(min_of_three(19, 15, 18) == 15);, assert(min_of_three(-10, -20, -30) == -30);]"
234,This is  a C++ function to set all even bits of a given number.,"```
#include <iostream>

std::pair<int, int> even_bit_set_number(int n) {
    int count = 0, res = 0, temp = n;
    while (temp > 0) {
        if (count % 2 == 1) {
            res |= (1 << count);
        }
        count++;
        temp >>= 1;
    }
    return {n | res, res};
}
```",235,"[assert(even_bit_set_number(10) == 10);, assert(even_bit_set_number(20) == 30);, assert(even_bit_set_number(30) == 30);]"
281,This is  a function to substaract two lists using map and lambda function.,"```
#include <cassert>
#include <vector>

std::vector<int> sub_list(const std::vector<int>& a, const std::vector<int>& b) {
    std::vector<int> result;
    for (size_t i = 0; i < a.size(); ++i) {
        result.push_back(a[i] - b[i]);
    }
    return result;
}```",282,"[assert((sub_list({ 1, 2, 3 }, { 4, 5, 6 }) == std::vector<int>{-3, -3, -3}));, assert((sub_list({ 1, 2 }, { 3, 4 }) == std::vector<int>{-2, -2}));, assert((sub_list({ 90, 120 }, { 50, 70 }) == std::vector<int>{40, 50}));]"
283,This is  a function to check whether all items of a list are equal to a given string.,"```
#include <cassert>
#include <vector>
#include <string>

bool check_element(const std::vector<std::string>& vec, const std::string& element) {
    return std::find(vec.begin(), vec.end(), element) != vec.end();
}

bool check_element(const std::vector<int>& vec, int element) {
    return std::find(vec.begin(), vec.end(), element) != vec.end();
}```",284,"[assert(check_element({ ""green"", ""orange"", ""black"", ""white"" }, ""blue"") == false);, assert(check_element({ 1, 2, 3, 4 }, 7) == false);, assert(check_element({ ""green"", ""green"", ""green"", ""green"" }, ""green"") == true);]"
306,This is  a function to get a colon of a tuple.,"```
#include <iostream>
#include <vector>
#include <variant>
#include <string>
#include <cassert>

using namespace std;

// Define a variant type to support different types in the tuple
using TupleElement = variant<string, int, vector<int>, bool>;
using Tuple = vector<TupleElement>;

// Function to modify the tuple at the given index
Tuple colon_tuplex(Tuple tuplex, int m, int n) {
    if (m >= 0 && m < tuplex.size() && holds_alternative<vector<int>>(tuplex[m])) {
        vector<int> newList = get<vector<int>>(tuplex[m]); // Copy the vector
        newList.push_back(n); // Modify the copy
        tuplex[m] = newList; // Store the modified vector back
    }
    return tuplex;
}

// Helper function to compare two tuples (vectors of std::variant)
bool tuples_are_equal(const Tuple& t1, const Tuple& t2) {
    if (t1.size() != t2.size()) return false;
    
    for (size_t i = 0; i < t1.size(); i++) {
        if (t1[i].index() != t2[i].index()) return false; // Different types
        
        if (holds_alternative<string>(t1[i]) && get<string>(t1[i]) != get<string>(t2[i]))
            return false;
        if (holds_alternative<int>(t1[i]) && get<int>(t1[i]) != get<int>(t2[i]))
            return false;
        if (holds_alternative<vector<int>>(t1[i]) && get<vector<int>>(t1[i]) != get<vector<int>>(t2[i]))
            return false;
        if (holds_alternative<bool>(t1[i]) && get<bool>(t1[i]) != get<bool>(t2[i]))
            return false;
    }
    
    return true;
}```",307,"[assert(tuples_are_equal( colon_tuplex({""HELLO"", 5, vector<int>{}, true}, 2, 50), {""HELLO"", 5, vector<int>{50}, true} ));, assert(tuples_are_equal( colon_tuplex({""HELLO"", 5, vector<int>{}, true}, 2, 100), {""HELLO"", 5, vector<int>{100}, true} ));, assert(tuples_are_equal( colon_tuplex({""HELLO"", 5, vector<int>{}, true}, 2, 500), {""HELLO"", 5, vector<int>{500}, true} ));]"
308,This is  a C++ function to find the maximum of two numbers.,"```
int maximum(int a, int b) {   
    if (a >= b) 
        return a; 
    else 
        return b; 
}
```",309,"[assert(maximum(5, 10) == 10);, assert(maximum(-1, -2) == -1);, assert(maximum(9, 7) == 9);]"
373,This is  a function to print all permutations of a given string including duplicates.,"```
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::string> permute_string(const std::string& str) {
    if (str.length() == 0) {
        return { """" };
    }
    std::vector<std::string> prev_list = permute_string(str.substr(1));
    std::vector<std::string> next_list;
    for (const auto& s : prev_list) {
        for (size_t j = 0; j <= str.length(); ++j) {
            std::string new_str = s.substr(0, j) + str[0] + s.substr(j);
            if (std::find(next_list.begin(), next_list.end(), new_str) == next_list.end()) {
                next_list.push_back(new_str);
            }
        }
    }
    return next_list;
}```",374,"[assert((permute_string(""ab"") == std::vector<std::string>{""ab"", ""ba""}));, assert((permute_string(""abc"") == std::vector<std::string>{""abc"", ""bac"", ""bca"", ""acb"", ""cab"", ""cba""}));, assert((permute_string(""abcd"") == std::vector<std::string>{""abcd"", ""bacd"", ""bcad"", ""bcda"", ""acbd"", ""cabd"", ""cbad"", ""cbda"", ""acdb"", ""cadb"", ""cdab"", ""cdba"", ""abdc"", ""badc"", ""bdac"", ""bdca"", ""adbc"", ""dabc"", ""dbac"", ""dbca"", ""adcb"", ""dacb"", ""dcab"", ""dcba""}));]"
383,This is  a C++ function to find the frequency of the smallest value in a given array.,"```
#include <cassert>
#include <vector>
#include <algorithm>

int frequency_Of_Smallest(int n, const std::vector<int>& arr) {
    int min_value = *std::min_element(arr.begin(), arr.end());
    return std::count(arr.begin(), arr.end(), min_value);
}```",384,"[assert(frequency_Of_Smallest(5, {1, 2, 3, 4, 3}) == 1);, assert(frequency_Of_Smallest(7, {3, 1, 2, 5, 6, 2, 3}) == 1);, assert(frequency_Of_Smallest(7, {3, 3, 6, 3, 7, 4, 9}) == 3);]"
387,This is  a C++ function to find the highest power of 2 that is less than or equal to n.,"```
int highest_Power_of_2(int n) { 
    int res = 0; 
    for (int i = n; i > 0; --i) { 
        if ((i & (i - 1)) == 0) { 
            res = i; 
            break; 
        } 
    } 
    return res; 
}
```",388,"[assert(highest_Power_of_2(10) == 8);, assert(highest_Power_of_2(19) == 16);, assert(highest_Power_of_2(32) == 32);]"
395,This is  a function to check whether the given string starts and ends with the same character or not using regex.,"```
#include <iostream>
#include <regex>
#include <string>

std::string check_char(const std::string& str) {
    std::regex regex(""^[a-z]$|^([a-z]).*\\1$"");
    if (std::regex_search(str, regex)) {
        return ""Valid"";
    } else {
        return ""Invalid"";
    }
}
```",396,"[assert(check_char(""abba"") == ""Valid"");, assert(check_char(""a"") == ""Valid"");, assert(check_char(""abcd"") == ""Invalid"");]"
409,This is  a function to find the minimum value in a given heterogeneous list.,"```
#include <iostream>
#include <vector>
#include <variant>
#include <cassert>
#include <stdexcept>
#include <algorithm>

using namespace std;

int minVal(const vector<variant<string, int>>& listVal) {
    vector<int> integers;

    for (const auto& item : listVal) {
        if (holds_alternative<int>(item)) {
            integers.push_back(get<int>(item));
        }
    }

    if (integers.empty()) {
        throw runtime_error(""No integers found""); // Handle the case where no integers exist
    }

    return *min_element(integers.begin(), integers.end());
}```",410,"[assert(minVal({ ""Python"", 3, 2, 4, 5, ""version"" }) == 2);, assert(minVal({ ""Python"", 15, 20, 25 }) == 15);, assert(minVal({ ""Python"", 30, 20, 40, 50, ""version"" }) == 20);]"
410,This is  a function to convert the given snake case string to camel case string by using regex.,"```
#include <iostream>
#include <string>
#include <sstream>
#include <cctype>
#include <cassert>

using namespace std;

// Function to capitalize the first character of a string
string capitalize(const string& str) {
    if (str.empty()) {
        return str;
    }
    string result = str;
    result[0] = toupper(result[0]);
    return result;
}

// Function to convert snake_case to camelCase
string snakeToCamel(const string& word) {
    stringstream ss;
    bool capitalizeNext = false;

    for (char c : word) {
        if (c == '_') {
            capitalizeNext = true;
        }
        else {
            if (capitalizeNext) {
                ss << static_cast<char>(toupper(c));
                capitalizeNext = false;
            }
            else {
                ss << c;
            }
        }
    }

    // Capitalize the first letter of the result
    string result = ss.str();
    if (!result.empty()) {
        result[0] = toupper(result[0]);
    }

    return result;
}```",411,"[assert(snakeToCamel(""android_tv"") == ""AndroidTv"");, assert(snakeToCamel(""google_pixel"") == ""GooglePixel"");, assert(snakeToCamel(""apple_watch"") == ""AppleWatch"");]"
425,This is  a function to filter odd numbers using lambda function.,"```
#include <vector>
#include <cassert>

std::vector<int> filter_oddnumbers(const std::vector<int> numbers) {
    std::vector<int> result;
    for (int num : numbers) {
        if (num % 2 != 0) {
            result.push_back(num);
        }
    }
    return result;
}```",426,"[assert(filter_oddnumbers({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == std::vector<int>{1, 3, 5, 7, 9});, assert(filter_oddnumbers({10, 20, 45, 67, 84, 93}) == std::vector<int>{45, 67, 93});, assert(filter_oddnumbers({5, 7, 9, 8, 6, 4, 3}) == std::vector<int>{5, 7, 9, 3});]"
448,This is  a C++ function to check whether the triangle is valid or not if 3 points are given.,"```
#include <iostream>

std::string check_Triangle(double x1, double y1, double x2, double y2, double x3, double y3) { 
    double a = (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));   
    if (a == 0) { 
        return ""No""; 
    } else { 
        return ""Yes""; 
    }
}
```",449,"[assert(check_Triangle(1, 5, 2, 5, 4, 6) == ""Yes"");, assert(check_Triangle(1, 1, 1, 4, 1, 5) == ""No"");, assert(check_Triangle(1, 1, 1, 1, 1, 1) == ""No"");]"
450,This is  a function to remove all whitespaces from the given string using regex.,"```

#include <string>
#include <algorithm>
#include <cctype>
#include <cassert>

std::string remove_whitespaces(const std::string& str) {
    std::string result;
    std::remove_copy_if(str.begin(), str.end(), std::back_inserter(result), ::isspace);
    return result;
}```",451,"[assert(remove_whitespaces("" Google    Flutter "") == ""GoogleFlutter"");, assert(remove_whitespaces("" Google    Dart "") == ""GoogleDart"");, assert(remove_whitespaces("" iOS    Swift "") == ""iOSSwift"");]"
465,This is  a function to find the peak element in the given array.,"```
#include <vector>

int find_peak_util(const std::vector<int>& arr, int low, int high, int n) {
    int mid = low + (high - low) / 2;
    
    if ((mid == 0 || arr[mid - 1] <= arr[mid]) &&
        (mid == n - 1 || arr[mid + 1] <= arr[mid])) {
        return mid;
    } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
        return find_peak_util(arr, low, mid - 1, n);
    } else {
        return find_peak_util(arr, mid + 1, high, n);
    }
}

int find_peak(const std::vector<int>& arr, int n) {
    return find_peak_util(arr, 0, n - 1, n);
}
```",466,"[assert(find_peak({1, 3, 20, 4, 1, 0}, 6) == 2);, assert(find_peak({2, 3, 4, 5, 6}, 5) == 4);, assert(find_peak({8, 9, 11, 12, 14, 15}, 6) == 5);]"
478,This is  a C++ function to find the first digit of a given number.,"```
int first_Digit(int n) {
    while (n >= 10) {
        n = n / 10;
    }
    return n;
}
```",479,"[assert(first_Digit(123) == 1);, assert(first_Digit(456) == 4);, assert(first_Digit(12) == 1);]"
485,This is  a function to compute binomial probability for the given number.,"```

#include <iostream>
#include <cmath>
#include <cassert>

using namespace std;

// Function to calculate nCr
long nCr(int n, int r) {
    if (r > n / 2) {
        r = n - r;
    }
    long answer = 1;
    for (int i = 1; i <= r; i++) {
        answer *= (n - r + i);
        answer /= i;
    }
    return answer;
}

// Function to calculate binomial probability
double binomialProbability(int n, int k, double p) {
    return (nCr(n, k) * pow(p, k) * pow(1 - p, n - k));
}```",486,"[assert(abs(binomialProbability(10, 5, 1.0 / 3) - 0.13656454808718185) < 1e-9);, assert(abs(binomialProbability(11, 6, 2.0 / 4) - 0.2255859375) < 1e-9);, assert(abs(binomialProbability(12, 7, 3.0 / 5) - 0.227030335488) < 1e-9);]"
489,This is  a function to extract all the pairs which are symmetric in the given tuple list.,"```
#include <iostream>
#include <set>
#include <vector>
#include <utility>
#include <cassert>

using namespace std;

set<pair<int, int>> extractSymmetric(const vector<pair<int, int>>& pairs) {
    set<pair<int, int>> result;
    set<pair<int, int>> seen;

    for (const auto& p : pairs) {
        pair<int, int> symmetric = { p.second, p.first };
        if (seen.count(symmetric)) {
            result.insert({ min(p.first, p.second), max(p.first, p.second) });
        }
        else {
            seen.insert(p);
        }
    }

    return result;
}```",490,"[assert((extractSymmetric({ {6, 7}, {2, 3}, {7, 6}, {9, 8}, {10, 2}, {8, 9} }) == set<pair<int, int>>{ {6, 7}, { 8, 9 }}));, assert((extractSymmetric({ {7, 8}, {3, 4}, {8, 7}, {10, 9}, {11, 3}, {9, 10} }) == set<pair<int, int>>{ {7, 8}, { 9, 10 }}));, assert((extractSymmetric({ {8, 9}, {4, 5}, {9, 8}, {11, 10}, {12, 4}, {10, 11} }) == set<pair<int, int>>{ {8, 9}, { 10, 11 }}));]"
510,This is  a C++ function to find minimum sum of factors of a given number.,"```
#include <iostream>

std::pair<int, int> find_Min_Sum(int num) {
    int sum = 0;
    int i = 2;
    while (i * i <= num) {
        while (num % i == 0) {
            sum += i;
            num /= i;
        }
        i += 1;
    }
    sum += num;
    return { sum, 0 }; // Assuming you want to return a second value as 0
}```",511,"[assert(find_Min_Sum(12).first == 7);, assert(find_Min_Sum(105).first == 15);, assert(find_Min_Sum(2).first == 2);]"
524,This is  a C++ function to check whether two given lines are parallel or not.,"```
#include <cassert>
#include <utility>
#include <cmath>

// Function to determine if two lines are parallel
bool parallel_lines(std::pair<double, double> line1, std::pair<double, double> line2) {
    // Avoid division by zero by using cross multiplication to compare slopes
    return std::abs(line1.first * line2.second - line2.first * line1.second) < 1e-9;
}```",525,"[assert(parallel_lines({ 2, 3 }, { 4, 6 }) == true);, assert(parallel_lines({ 2, 3 }, { 4, -6 }) == false);, assert(parallel_lines({ 3, 3 }, { 5, 5 }) == true);  ]"
541,"This is  a function to replace all occurrences of spaces, commas, or dots with a colon in the given string by using regex.","```
#include <string>
#include <regex>
#include <cassert>

std::string fill_spaces(const std::string& text) {
    // Replace spaces, commas, and periods with "":""
    return std::regex_replace(text, std::regex(""[ ,.]+""), "":"");
}```",542,"[assert(fill_spaces(""Boult Curve Wireless Neckband"") == ""Boult:Curve:Wireless:Neckband"");, assert(fill_spaces(""Stereo Sound Sweatproof"") == ""Stereo:Sound:Sweatproof"");, assert(fill_spaces(""Probass Curve Audio"") == ""Probass:Curve:Audio"");]"
545,This is  a function to find the last occurrence of a character in a string.,"```
#include <string>

int last_occurrence_char(const std::string& str, char ch) {
    int flag = -1;
    for (int i = 0; i < str.length(); i++) {
        if (str[i] == ch) {
            flag = i;
        }
    }
    if (flag == -1) {
        return -1; // Returning -1, -1 to indicate None
    }
    else {
        return flag + 1; // Returning the position + 1 and a second value (0 for consistency)
    }
}```",546,"[assert(last_occurrence_char(""hello world"", \l\) == 10);, assert(last_occurrence_char(""language"", \g\) == 7);, assert(last_occurrence_char(""little"", \y\) == -1);]"
565,This is  a function to get the sum of a non-negative integer.,"```
#include <iostream>

int sum_digits(int n) {
    if (n == 0) {
        return 0;
    } else {
        return n % 10 + sum_digits(n / 10);
    }
}
```",566,"[assert(sum_digits(345) == 12);, assert(sum_digits(12) == 3);, assert(sum_digits(97) == 16);]"
568,This is  a function to sort each sublist of strings in a given list of lists.,"```
#include <algorithm>
#include <algorithm>
#include<string>
#include <vector>

std::vector<std::vector<std::string>> sort_sublists(const std::vector<std::vector<std::string>>& list1) {
    std::vector<std::vector<std::string>> result = list1;
    for (auto& sublist : result) {
        std::sort(sublist.begin(), sublist.end());
    }
    return result;
}```",569,"[assert(sort_sublists({ {""green"", ""orange""}, {""black"", ""white""}, {""white"", ""black"", ""orange""} }) == (std::vector<std::vector<std::string>>{ {""green"", ""orange""}, { ""black"", ""white"" }, { ""black"", ""orange"", ""white"" }}));, assert(sort_sublists({ {""green"", ""orange""}, {""black""}, {""green"", ""orange""}, {""white""} }) == (std::vector<std::vector<std::string>>{ {""green"", ""orange""}, { ""black"" }, { ""green"", ""orange"" }, { ""white"" }}));, assert(sort_sublists({ {""a"",""b""}, {""d"",""c""}, {""g"",""h""}, {""f"",""e""} }) == (std::vector<std::vector<std::string>>{ {""a"", ""b""}, { ""c"", ""d"" }, { ""g"", ""h"" }, { ""e"", ""f"" }}));]"
570,This is  a function to find maximum possible sum of disjoint pairs for the given array of integers and a number k.,"```
#include <vector>
#include <algorithm>

int max_sum_pair_diff_lessthan_K(std::vector<int> arr, int N, int K) {
    std::sort(arr.begin(), arr.end());
    std::vector<int> dp(N, 0);
    dp[0] = 0;
    for (int i = 1; i < N; ++i) {
        dp[i] = dp[i - 1];
        if (arr[i] - arr[i - 1] < K) {
            if (i >= 2) {
                dp[i] = std::max(dp[i], dp[i - 2] + arr[i] + arr[i - 1]);
            }
            else {
                dp[i] = std::max(dp[i], arr[i] + arr[i - 1]);
            }
        }
    }
    return dp[N - 1]; // Returning a second value as 0 to match the return type
}```",571,"[assert(max_sum_pair_diff_lessthan_K({ 3, 5, 10, 15, 17, 12, 9 }, 7, 4) == 62);, assert(max_sum_pair_diff_lessthan_K({ 5, 15, 10, 300 }, 4, 12) == 25);, assert(max_sum_pair_diff_lessthan_K({ 1, 2, 3, 4, 5, 6 }, 6, 6) == 21);]"
595,This is  a function to find the size of the given tuple.,"```
#include <cassert>
#include <tuple>
#include <iostream>

// Function to calculate the size of a tuple
template <typename... Args>
size_t tupleSize(const std::tuple<Args...>& t) {
    return sizeof...(Args);  // Return the number of elements in the tuple
}```",596,"[""assert(tupleSize(std::tuple<int, double, char>(10, 3.14, A)) == 3);  // Tuple has 3 elements"", assert(tupleSize(std::tuple<>{}) == 0);  // Empty tuple, size should be 0, ""assert(tupleSize(std::tuple<int, std::tuple<double, char>>(5, std::make_tuple(3.14, A))) == 2);  // Tuple has 2 elements (int and nested tuple)"", assert(tupleSize(std::tuple<float>(2.5f)) == 1);  // Only 1 element in the tuple]"
599,This is  a C++ function to check whether the given number is even or not using bitwise operator.,"```
bool is_Even(int n) {
    if ((n ^ 1) == (n + 1)) {
        return true;
    } else {
        return false;
    }
}
```",600,"[assert(is_Even(1) == false);, assert(is_Even(2) == true);, assert(is_Even(3) == false);]"
601,This is  a C++ function to find the first repeated character in a given string.,"```
#include <string>
#include <unordered_map>

std::string first_repeated_char(const std::string& str1) {
    std::unordered_map<char, int> char_count;
    for (size_t index = 0; index < str1.length(); ++index) {
        char c = str1[index];
        char_count[c]++;
        if (char_count[c] > 1) {
            return std::string(1, c);
        }
    }
    return ""None"";
}
```",602,"[assert(first_repeated_char(""abcabc"") == ""a"");, assert(first_repeated_char(""abc"") == ""None"");, assert(first_repeated_char(""123123"") == ""1"");]"
603,This is  a function to reverse words in a given string.,"```
#include <iostream>
#include <sstream>
#include <vector>
#include <algorithm>

std::string reverse_words(const std::string& s) {
    std::istringstream iss(s);
    std::vector<std::string> words;
    std::string word;

    while (iss >> word) {
        words.push_back(word);
    }

    std::reverse(words.begin(), words.end());

    std::ostringstream oss;
    for (const auto& w : words) {
        oss << w << "" "";
    }

    std::string result = oss.str();
    if (!result.empty()) {
        result.pop_back(); // remove the trailing space
    }

    return result;
}
```",604,"[assert(reverse_words(""C++ program"") == ""program C++"");, assert(reverse_words(""java language"") == ""language java"");, assert(reverse_words(""indian man"") == ""man indian"");]"
608,This is  a C++ function to find minimum possible value for the given periodic function.,"```
#include <algorithm>

int floor_Min(int A, int B, int N) {
    int x = std::max(B - 1, N);
    return (A * x) / B;
}```",609,"[assert(floor_Min(10, 20, 30) == 15);, assert(floor_Min(1, 2, 1) == 0);, assert(floor_Min(11, 10, 9) == 9);]"
611,This is  a C++ function to merge the first and last elements separately in a list of lists.,"```
#include <vector>
#include <string>
#include <tuple>
#include <algorithm>

// Function to transpose the matrix
template <typename T>
std::vector<std::vector<T>> merge(const std::vector<std::vector<T>>& lst) {
    std::vector<std::vector<T>> result;
    if (lst.empty()) return result;

    size_t numberOfRows = lst.size();
    size_t numberOfCols = lst[0].size();
    result.resize(numberOfCols, std::vector<T>(numberOfRows));

    for (size_t j = 0; j < numberOfCols; ++j) {
        for (size_t i = 0; i < numberOfRows; ++i) {
            result[j][i] = lst[i][j];
        }
    }

    return result;
}```",612,"[assert((merge<std::string>({ {""x"", ""y""}, {""a"", ""b""}, {""m"", ""n""} }) == std::vector<std::vector<std::string>>{ {""x"", ""a"", ""m""}, { ""y"", ""b"", ""n"" }}));, assert((merge<int>({ {1, 2}, {3, 4}, {5, 6}, {7, 8} }) == std::vector<std::vector<int>>{ {1, 3, 5, 7}, { 2, 4, 6, 8 }}));, assert((merge<std::string>({ {""x"", ""y"", ""z""}, {""a"", ""b"", ""c""}, {""m"", ""n"", ""o""} }) == std::vector<std::vector<std::string>>{ {""x"", ""a"", ""m""}, { ""y"", ""b"", ""n"" }, { ""z"", ""c"", ""o"" }}));]"
638,This is  a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.,"```
#include <string>
#include <vector>
#include <algorithm>

int sample_nam(std::vector<std::string> sample_names) {
    sample_names.erase(std::remove_if(sample_names.begin(), sample_names.end(), [](const std::string& el) {
        return !(std::isupper(el[0]) && std::all_of(el.begin() + 1, el.end(), [](char c) { return std::islower(c); }));
        }), sample_names.end());

    std::string joined;
    for (const auto& name : sample_names) {
        joined += name;
    }
    return static_cast<int>(joined.length());
}```",639,"[assert(sample_nam({""sally"", ""Dylan"", ""rebecca"", ""Diana"", ""Joanne"", ""keith""}) == 16);, assert(sample_nam({""php"", ""res"", ""C++"", ""abcd"", ""Java"", ""aaa""}) == 10);, assert(sample_nam({""abcd"", ""C++"", ""abba"", ""aba""}) == 6);]"
640,This is  a function to find the nth nonagonal number.,"```
int is_nonagonal(int n) {
    return static_cast<int>(n * (7 * n - 5) / 2);
}
```",641,"[assert(is_nonagonal(10) == 325);, assert(is_nonagonal(15) == 750);, assert(is_nonagonal(18) == 1089);]"
644,This is  a function to find the product of it’s kth index in the given tuples.,"```
#include <vector>



long long find_k_product(const std::vector<std::vector<int>>& test_list, int K) {
    std::vector<int> sub_k_values;
    for (const auto& sub : test_list) {
        sub_k_values.push_back(sub[K]);
    }
    
    long long res2 = 1;
    for (const auto& ele : sub_k_values) {
        res2 *= ele;
    }
    return res2;
}```",645,"[assert(find_k_product({ {5, 6, 7}, {1, 3, 5}, {8, 9, 19} }, 2) == 665);, assert(find_k_product({ {6, 7, 8}, {2, 4, 6}, {9, 10, 20} }, 1) == 280);, assert(find_k_product({ {7, 8, 9}, {3, 5, 7}, {10, 11, 21} }, 0) == 210);]"
648,This is  a C++ function to calculate the sum of the numbers in a list between the indices of a specified range.,"```
#include <vector>

int sum_Range_list(const std::vector<int>& nums, int m, int n) {
    int sum_range = 0;
    for (int i = m; i <= n; ++i) {
        sum_range += nums[i];
    }
    return sum_range;
}```",649,"[assert(sum_Range_list({2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12}, 8, 10) == 29);, assert(sum_Range_list({1, 2, 3, 4, 5}, 1, 2) == 5);, assert(sum_Range_list({1, 0, 1, 2, 5, 6}, 4, 5) == 11);]"
658,This is  a C++ function to print duplicants from a list of integers.,"```
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> Repeat(const std::vector<int>& x) {
    int _size = x.size();
    std::vector<int> repeated;

    for (int i = 0; i < _size; ++i) {
        int k = i + 1;
        for (int j = k; j < _size; ++j) {
            if (x[i] == x[j] && std::find(repeated.begin(), repeated.end(), x[i]) == repeated.end()) {
                repeated.push_back(x[i]);
            }
        }
    }
    return repeated ;
}```",659,"[assert((Repeat({ 10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20 }) == std::vector<int>{20, 30, -20, 60}));, assert(Repeat({ -1, 1, -1, 8 }) == std::vector<int>{-1});, assert((Repeat({ 1, 2, 3, 1, 2 }) == std::vector<int>{1, 2}));]"
670,This is  a C++ function to set the right most unset bit.,"```
#include <cmath>

int get_Pos_Of_Right_most_Set_Bit(int n) { 
    return static_cast<int>(log2(n & -n) + 1);   
}

int set_Right_most_Unset_Bit(int n) { 
    if (n == 0) { 
        return 1; 
    }
    if ((n & (n + 1)) == 0) {     
        return n; 
    }
    int pos = get_Pos_Of_Right_most_Set_Bit(~n);      
    return ((1 << (pos - 1)) | n); 
}
```",671,"[assert(set_Right_most_Unset_Bit(21) == 23);, assert(set_Right_most_Unset_Bit(11) == 15);, assert(set_Right_most_Unset_Bit(15) == 15);]"
673,This is  a function to remove duplicate words from a given string using collections module.,"```
#include <iostream>
#include <sstream>
#include <unordered_map>
#include <vector>

std::string remove_duplicate(const std::string& str) {
    std::istringstream iss(str);
    std::unordered_map<std::string, bool> wordMap;
    std::vector<std::string> uniqueWords;
    std::string word;
    
    while (iss >> word) {
        if (wordMap.find(word) == wordMap.end()) {
            wordMap[word] = true;
            uniqueWords.push_back(word);
        }
    }

    std::string result;
    for (const auto& w : uniqueWords) {
        result += w + "" "";
    }
    
    if (!result.empty()) {
        result.pop_back(); // remove the trailing space
    }
    
    return result;
}
```",674,"[assert(remove_duplicate(""C++ Exercises Practice Solution Exercises"") == ""C++ Exercises Practice Solution"");, assert(remove_duplicate(""C++ Exercises Practice Solution C++"") == ""C++ Exercises Practice Solution"");, assert(remove_duplicate(""C++ Exercises Practice Solution Practice"") == ""C++ Exercises Practice Solution"");]"
681,This is  a function to multiply two lists using map and lambda function.,"```
#include <vector>

std::vector<int> mul_list(const std::vector<int>& a, const std::vector<int>& b) {
    std::vector<int> result;
    for (size_t i = 0; i < a.size(); i++) {
        result.push_back(a[i] * b[i]);
    }
    return result;
}```",682,"[assert(mul_list({ 1, 2, 3 }, { 4, 5, 6 }) == std::vector<int>({ 4, 10, 18 }));, assert(mul_list({ 1, 2 }, { 3, 4 }) == std::vector<int>({ 3, 8 }));, assert(mul_list({ 90, 120 }, { 50, 70 }) == std::vector<int>({ 4500, 8400 }));]"
686,This is  a function to find the greatest common divisor (gcd) of two integers by using recursion.,"```
#include <iostream>
#include <algorithm>

int recur_gcd(int a, int b) {
    int low = std::min(a, b);
    int high = std::max(a, b);
    if (low == 0) {
        return high;
    } else if (low == 1) {
        return 1;
    } else {
        return recur_gcd(low, high % low);
    }
}
```",687,"[assert(recur_gcd(12, 14) == 2);, assert(recur_gcd(13, 17) == 1);, assert(recur_gcd(9, 3) == 3);]"
708,This is  a function to count unique keys for each value present in the tuple.,"```
// Function to get unique elements
std::pair<std::string, std::unordered_map<int, int>> get_unique(const std::vector<std::pair<int, int>>& test_list) {
    std::unordered_map<int, std::vector<int>> res;

    // Group by the second value and store first values in a vector
    for (const auto& sub : test_list) {
        res[sub.second].push_back(sub.first);
    }

    // Count unique elements for each key
    std::unordered_map<int, int> res_dict;
    for (const auto& pair : res) {
        std::set<int> unique_elements(pair.second.begin(), pair.second.end());
        res_dict[pair.first] = unique_elements.size();
    }

    // Convert map to string representation
    std::ostringstream oss;
    oss << ""{"";
    for (auto it = res_dict.begin(); it != res_dict.end(); ++it) {
        if (it != res_dict.begin()) oss << "", "";
        oss << it->first << "": "" << it->second;
    }
    oss << ""}"";

    return { oss.str(), res_dict };
}```",709,"[assert(get_unique({ {3, 4}, {1, 2}, {2, 4}, {8, 2}, {7, 2}, {8, 1}, {9, 1}, {8, 4}, {10, 4} }).first == ""{4: 4, 2: 3, 1: 2}"");, assert(get_unique({ {4, 5}, {2, 3}, {3, 5}, {9, 3}, {8, 3}, {9, 2}, {10, 2}, {9, 5}, {11, 5} }).first == ""{5: 4, 3: 3, 2: 2}"");]"
710,This is  a C++ function to check whether the product of digits of a number at even and odd places is equal or not.,"```
#include <iostream>
using namespace std;

bool product_Equal(int n) {
    if (n < 10) {
        return false;
    }
    int prodOdd = 1, prodEven = 1;
    while (n > 0) {
        int digit = n % 10;
        prodOdd *= digit;
        n = n / 10;
        if (n == 0) {
            break;
        }
        digit = n % 10;
        prodEven *= digit;
        n = n / 10;
    }
    return prodOdd == prodEven;
}
```",711,"[assert(product_Equal(2841) == true);, assert(product_Equal(1234) == false);, assert(product_Equal(1212) == false);]"
711,This is  a function to remove duplicates from a list of lists.,"```
#include <cassert>
#include <algorithm>
#include <vector>
#include <string>

// Function to remove duplicates from a vector of integers
std::vector<int> remove_duplicate(std::vector<int> list1) {
    std::sort(list1.begin(), list1.end());
    list1.erase(std::unique(list1.begin(), list1.end()), list1.end());
    return list1;
}```",712,"[assert((remove_duplicate({ 10, 20, 40, 10, 33, 40 }) == std::vector<int>{10, 20, 33, 40}));, assert((remove_duplicate({ 1, 3, 5, 6, 3, 5, 6, 1 }) == std::vector<int>{1, 3, 5, 6}));, assert(remove_duplicate({5,5,5,5,5 }) == std::vector<int>{5}); assert((remove_duplicate({ 10, 20, 40, 10, 33, 40 }) == std::vector<int>{10, 20, 33, 40}));, assert((remove_duplicate({ 1, 3, 5, 6, 3, 5, 6, 1 }) == std::vector<int>{1, 3, 5, 6}));, assert(remove_duplicate({5,5,5,5,5 }) == std::vector<int>{5});]"
736,This is  a function to check whether the given string is starting with a vowel or not using regex.,"```
#include <iostream>
#include <regex>
#include <string>

std::string check_str(const std::string& str) {
    std::regex regex(""^[aeiouAEIOU][A-Za-z0-9_]*"");
    if (std::regex_search(str, regex)) {
        return ""Valid"";
    } else {
        return ""Invalid"";
    }
}
```",737,"[assert(check_str(""annie"") == ""Valid"");, assert(check_str(""dawood"") == ""Invalid"");, assert(check_str(""Else"") == ""Valid"");]"
752,This is  a function to find minimum k records from tuple list.,"```
#include <vector>
#include <algorithm>
#include <string> // For std::string

std::vector<std::pair<std::string, int>> min_k(const std::vector<std::pair<std::string, int>>& test_list, int K) {
    std::vector<std::pair<std::string, int>> res = test_list;
    std::sort(res.begin(), res.end(), [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {
        return a.second < b.second;  // Sorting based on the second element of the pair (the integer)
        });
    res.resize(K);  // Resize the vector to retain only the top K elements
    return res;
}```",753,"[assert((min_k({ {""Manjeet"", 10}, {""Akshat"", 4}, {""Akash"", 2}, {""Nikhil"", 8} }, 2) == std::vector<std::pair<std::string, int>>{ {""Akash"", 2}, { ""Akshat"", 4 }}));, assert((min_k({ {""Sanjeev"", 11}, {""Angat"", 5}, {""Akash"", 3}, {""Nepin"", 9} }, 3) == std::vector<std::pair<std::string, int>>{ {""Akash"", 3}, { ""Angat"", 5 }, { ""Nepin"", 9 }}));, assert((min_k({ {""tanmay"", 14}, {""Amer"", 11}, {""Ayesha"", 9}, {""SKD"", 16} }, 1) == std::vector<std::pair<std::string, int>>{ {""Ayesha"", 9} }));]"
772,This is  a function to find the occurrence and position of the substrings within a string.,"```
#include <string>
#include <tuple>

std::tuple<std::string, int, int> occurance_substring(const std::string& str, const std::string& sub) {
    size_t pos = str.find(sub);
    if (pos != std::string::npos) {
        return std::make_tuple(sub, pos, pos + sub.length());
    }
    return std::make_tuple("""", -1, -1);
}```",773,"[assert(occurance_substring(""C++ programming, C++ language"", ""C++"") == std::make_tuple(""C++"", 0, 6));, assert(occurance_substring(""C++ programming,programming language"", ""programming"") == std::make_tuple(""programming"", 7, 18));, assert(occurance_substring(""C++ programming,programming language"", ""language"") == std::make_tuple(""language"", 31, 39));]"
782,This is  a function to convert rgb color to hsv color.,"#include <algorithm>
#include <tuple>

std::tuple<double, double, double> rgb_to_hsv(int r, int g, int b) {
    r /= 255.0;
    g /= 255.0;
    b /= 255.0;
    double mx = std::max({r, g, b});
    double mn = std::min({r, g, b});
    double df = mx - mn;
    double h, s, v;

    if (mx == mn) {
        h = 0;
    } else if (mx == r) {
        h = fmod((60 * ((g - b) / df) + 360), 360);
    } else if (mx == g) {
        h = fmod((60 * ((b - r) / df) + 120), 360);
    } else if (mx == b) {
        h = fmod((60 * ((r - g) / df) + 240), 360);
    }

    if (mx == 0) {
        s = 0;
    } else {
        s = (df / mx) * 100;
    }
    v = mx * 100;

    return std::make_tuple(h, s, v);
}",783,"[assert(rgb_to_hsv(255, 255, 255) == std::make_tuple(0.0, 0.0, 100.0));, assert(rgb_to_hsv(0, 215, 0) == std::make_tuple(120.0, 100.0, 84.31372549019608));, assert(rgb_to_hsv(10, 215, 110) == std::make_tuple(149.26829268292684, 95.34883720930233, 84.31372549019608));]"
805,This is  a function to find maximum run of uppercase characters in the given string.,"```
#include <iostream>
#include <string>

int max_run_uppercase(const std::string& test_str) {
    int cnt = 0;
    int res = 0;
    for (size_t idx = 0; idx < test_str.length(); idx++) {
        if (isupper(test_str[idx])) {
            cnt++;
        }
        else {
            res = cnt;
            cnt = 0;
        }
    }
    if (isupper(test_str[test_str.length() - 1])) {
        res = cnt;
    }
    return res;
}```",806,"[assert(max_run_uppercase(""GeMKSForGERksISBESt"") == 5);, assert(max_run_uppercase(""PrECIOusMOVemENTSYT"") == 6);, assert(max_run_uppercase(""GooGLEFluTTER"") == 4);]"
812,This is  a function to find length of the string.,"```
#include <string>

int string_length(const std::string  str) {
    return str.length();
}```",813,"[assert(string_length(""C++"") == 3);, assert(string_length(""program"") == 7);, assert(string_length(""language"") == 8);]"
813,This is  a function to find the area of a rombus.,"```
double rombus_area(double p, double q) {
    double area = (p * q) / 2;
    return area;
}
```",814,"[assert(rombus_area(10, 20) == 100);, assert(rombus_area(10, 5) == 25);, assert(rombus_area(4, 2) == 4);]"
820,This is  a function to merge two dictionaries into a single expression.,"```
#include <unordered_map>
#include <string>

std::unordered_map<std::string, std::string> merge_dictionaries(const std::unordered_map<std::string, std::string>& dict1, const std::unordered_map<std::string, std::string>& dict2) {
    std::unordered_map<std::string, std::string> merged = dict1;

    for (const auto& pair : dict2) {
        merged[pair.first] = pair.second;
    }

    return merged;
}```",821,"[assert(merge_dictionaries({{""R"", ""Red""}, {""B"", ""Black""}, {""P"", ""Pink""}}, {{""G"", ""Green""}, {""W"", ""White""}}) == (std::unordered_map<std::string, std::string>{{""B"", ""Black""}, {""R"", ""Red""}, {""P"", ""Pink""}, {""G"", ""Green""}, {""W"", ""White""}}));, assert(merge_dictionaries({{""R"", ""Red""}, {""B"", ""Black""}, {""P"", ""Pink""}}, {{""O"", ""Orange""}, {""W"", ""White""}, {""B"", ""Black""}}) == (std::unordered_map<std::string, std::string>{{""O"", ""Orange""}, {""P"", ""Pink""}, {""B"", ""Black""}, {""W"", ""White""}, {""R"", ""Red""}}));, assert(merge_dictionaries({{""G"", ""Green""}, {""W"", ""White""}}, {{""O"", ""Orange""}, {""W"", ""White""}, {""B"", ""Black""}}) == (std::unordered_map<std::string, std::string>{{""W"", ""White""}, {""O"", ""Orange""}, {""G"", ""Green""}, {""B"", ""Black""}}));]"
856,This is  a function to list out the list of given strings individually using map function.,"```
#include <vector>
#include <list>
#include <string>
#include <cassert>

std::vector<std::list<char>> listify_list(const std::vector<std::string>& list1) {
    std::vector<std::list<char>> result;
    for (const auto& str : list1) {
        result.emplace_back(str.begin(), str.end());
    }
    return result;
}```",857," [""assert((listify_list({""Red"", ""Blue"", ""Black"", ""White"", ""Pink""}) == 
           std::vector<std::list<char>>{{R, e, d}, {B, l, u, e}, 
                                        {B, l, a, c, k}, {W, h, i, t, e}, 
                                        {P, i, n, k}}));"",

   "" assert((listify_list({""C++""}) == std::vector<std::list<char>>{{C, +, +}}));"",

  ""  assert((listify_list({"" red "", ""green"", "" black"", ""blue "", "" orange"", ""brown""}) == 
           std::vector<std::list<char>>{{ , r, e, d,  }, {g, r, e, e, n}, 
                                        { , b, l, a, c, k}, {b, l, u, e,  }, 
                                        { , o, r, a, n, g, e}, {b, r, o, w, n}}));""]"
888,This is  a function to reverse each list in a given list of lists.,"```
#include <algorithm>
#include <vector>

std::vector<std::vector<int>> reverse_list_lists(std::vector<std::vector<int>> lists) {
    for (auto& l : lists) {
        std::sort(l.rbegin(), l.rend()); // Reverse sort each list
    }
    return lists; // Return the modified lists
}```",889,"[assert((reverse_list_lists({ {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16} }) == std::vector<std::vector<int>>{ {4, 3, 2, 1}, { 8, 7, 6, 5 }, { 12, 11, 10, 9 }, { 16, 15, 14, 13 } }));, assert((reverse_list_lists({ {1, 2}, {2, 3}, {3, 4} }) == std::vector<std::vector<int>>{ {2, 1}, { 3, 2 }, { 4, 3 } }));, assert((reverse_list_lists({ {10, 20}, {30, 40} }) == std::vector<std::vector<int>>{ {20, 10}, { 40, 30 } }));]"
892,This is  a C++ function to get the last element of each sublist.,"```
#include <vector>
#include <string>

// Template function to handle both integers and strings
template <typename T>
std::vector<T> Extract(const std::vector<std::vector<T>>& input) {
    std::vector<T> result;
    for (const auto& vec : input) {
        if (!vec.empty()) {
            result.push_back(vec.back());
        }
    }
    return result;
}```",893,"[assert((Extract<int>({ {1, 2, 3}, {4, 5}, {6, 7, 8, 9} }) == std::vector<int>{3, 5, 9}));, assert((Extract<std::string>({ {""x"", ""y"", ""z""}, {""m""}, {""a"", ""b""}, {""u"", ""v""} }) == std::vector<std::string>{""z"", ""m"", ""b"", ""v""}));, assert((Extract<int>({ {1, 2, 3}, {4, 5} }) == std::vector<int>{3, 5}));]"
900,This is  a function to find the smallest multiple of the first n numbers.,"```
#include <iostream>
#include <vector>

int smallest_multiple(int n) {
    if (n <= 2) {
        return n;
    }

    int i = n * 2;
    std::vector<int> factors;
    for (int number = n; number > 1; --number) {
        if (number * 2 > n) {
            factors.push_back(number);
        }
    }

    while (true) {
        for (auto a : factors) {
            if (i % a != 0) {
                i += n;
                break;
            }
            if (a == factors.back() && i % a == 0) {
                return i;
            }
        }
    }
}```",901,"[assert(smallest_multiple(13) == 360360);, assert(smallest_multiple(2) == 2);, assert(smallest_multiple(1) == 1);]"
902,This is  a C++ function to count the total unset bits from 1 to n.,"```
int count_Unset_Bits(int n) {  
    int cnt = 0;  
    for (int i = 1; i <= n; i++) {  
        int temp = i;  
        while (temp) {  
            if (temp % 2 == 0) {  
                cnt++;  
            }  
            temp = temp / 2;  
        }  
    }  
    return cnt;  
}
```",903,"[assert(count_Unset_Bits(2) == 1);, assert(count_Unset_Bits(5) == 4);, assert(count_Unset_Bits(14) == 17);]"
914,This is  a function to rearrange positive and negative numbers in a given array using lambda function.,"```
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>
#include <cmath>

std::vector<int> rearrangeNumbs(const std::vector<int>& arrayNums) {
    std::vector<int> wrapperArray(arrayNums.begin(), arrayNums.end());

    std::sort(wrapperArray.begin(), wrapperArray.end(), [](int i1, int i2) {
        if (i1 >= 0 && i2 >= 0) {
            return i1 < i2;
        }
        else if (i1 < 0 && i2 < 0) {
            return std::abs(i2) < std::abs(i1);  // Sort by absolute value in descending order for negative numbers
        }
        return i1 > i2;  // Negative numbers should come after positive numbers
        });

    return wrapperArray;
}```",915,"[assert((rearrangeNumbs({ -1, 2, -3, 5, 7, 8, 9, -10 }) == std::vector<int>{2, 5, 7, 8, 9, -10, -3, -1}));, assert((rearrangeNumbs({ 10, 15, 14, 13, -18, 12, -20 }) == std::vector<int>{10, 12, 13, 14, 15, -20, -18}));, assert((rearrangeNumbs({ -20, 20, -10, 10, -30, 30 }) == std::vector<int>{10, 20, 30, -30, -20, -10}));]"
917,This is  a function to count coin change.,"```
#include <iostream>
#include <vector>
#include <cassert>

int coinChange(const std::vector<int>& S, int m, int n) {
    std::vector<std::vector<int>> table(n + 1, std::vector<int>(m, 0));

    // Base case: If n = 0, there's 1 way to make the sum 0 (using no coins)
    for (int i = 0; i < m; i++) {
        table[0][i] = 1;
    }

    // Fill the table for all sums from 1 to n
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < m; j++) {
            int x = (i - S[j] >= 0) ? table[i - S[j]][j] : 0;
            int y = (j >= 1) ? table[i][j - 1] : 0;
            table[i][j] = x + y;
        }
    }

    return table[n][m - 1];
}```",918,"[assert(coinChange({ 1, 2, 3 }, 3, 4) == 4);, assert(coinChange({ 4, 5, 6, 7, 8, 9 }, 6, 9) == 2);, assert(coinChange({ 4, 5, 6, 7, 8, 9 }, 6, 4) == 1);]"
927,This is  a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.,"```
#include <cassert>
#include <string>
#include <regex>

std::string change_date_format(const std::string& dt) {
    return std::regex_replace(dt, std::regex(R""((\d{4})-(\d{1,2})-(\d{1,2}))""), ""$3-$2-$1"");
}```",928,"[assert(change_date_format(""2026-01-02"") == ""02-01-2026"");, assert(change_date_format(""2021-01-04"") == ""04-01-2021"");, assert(change_date_format(""2030-06-06"") == ""06-06-2030"");]"
940,This is  a function to count the elements in a list until an element is a tuple.,"```
#include <iostream>
#include <vector>
#include <cassert>
#include <type_traits>

using namespace std;

int countElim(const vector<void*>& num) {
    int countElim = 0;
    for (auto n : num) {
        // If the element is a pointer to another vector, break the loop
        if (n == nullptr) { // Using nullptr to simulate checking for a nested vector
            break;
        }
        countElim++;
    }
    return countElim;
}```",941,"[assert(countElim({ (void*)10, (void*)20, (void*)30, nullptr, (void*)40 }) == 3);, assert(countElim({ (void*)10, nullptr, nullptr, (void*)40 }) == 1);, assert(countElim({ nullptr }) == 0);]"
956,This is  a C++ function to get the position of rightmost set bit.,"```
#include <cmath>

double get_First_Set_Bit_Pos(int n) {
    return  log2(n & -n) + 1; // The second value can be adjusted if needed
}```",957,"[assert(get_First_Set_Bit_Pos(12) == 3);, assert(get_First_Set_Bit_Pos(18) == 2);, assert(get_First_Set_Bit_Pos(16) == 5);]"
967,This is  a C++ function to find maximum possible value for the given periodic function.,"```
#include <algorithm>

int floor_Max(int a, int b, int c) {
    return std::min({ a, b, c });
}```",968,"[assert(floor_Max(11, 10, 9) == 9);, assert(floor_Max(5, 7, 4) == 4);, assert(floor_Max(2, 2, 1) == 1);]"
976,"    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    0.5
    """"""
","```
#include <cmath>

double truncate_number(double number) {
    return fmod(number, 1.0);
}
```",977,"[assert(truncate_number(3.5) == 0.5);, assert(abs(truncate_number(1.33) - 0.33) < 1e-6);, assert(abs(truncate_number(123.456) - 0.456) < 1e-6);]"
993,"    """""" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    'one three five'
    """"""
","```
#include <iostream>
#include <map>
#include <sstream>
#include <vector>
#include <algorithm>

std::string sort_numbers(const std::string& numbers) {
    std::map<std::string, int> value_map = {
        {""zero"", 0},
        {""one"", 1},
        {""two"", 2},
        {""three"", 3},
        {""four"", 4},
        {""five"", 5},
        {""six"", 6},
        {""seven"", 7},
        {""eight"", 8},
        {""nine"", 9}
    };

    std::istringstream iss(numbers);
    std::vector<std::string> num_vector;
    std::string num;

    while (iss >> num) {
        if (!num.empty()) {
            num_vector.push_back(num);
        }
    }

    std::sort(num_vector.begin(), num_vector.end(), [&](const std::string& a, const std::string& b) {
        return value_map[a] < value_map[b];
        });

    std::ostringstream oss;
    for (const auto& n : num_vector) {
        oss << n << ' ';
    }

    std::string result = oss.str();
    if (!result.empty()) {
        result.pop_back(); // Remove trailing space
    }

    return result;
}```",994,"[assert(sort_numbers("""") == """");, assert(sort_numbers(""three"") == ""three"");, assert(sort_numbers(""three five nine"") == ""three five nine"");, assert(sort_numbers(""five zero four seven nine eight"") == ""zero four five seven eight nine"");, assert(sort_numbers(""six five four three two one zero"") == ""zero one two three four five six"");]"
995,"    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """"""
","```
#include <iostream>
#include <vector>
#include <limits>
#include <cassert>

std::vector<double> rescaleToUnit(const std::vector<double>& numbers) {
    double minNumber = std::numeric_limits<double>::max();
    double maxNumber = std::numeric_limits<double>::min();

    for (double num : numbers) {
        if (num < minNumber) minNumber = num;
        if (num > maxNumber) maxNumber = num;
    }

    std::vector<double> rescaled;
    for (double x : numbers) {
        rescaled.push_back((x - minNumber) / (maxNumber - minNumber));
    }

    return rescaled;
}```",996,"[assert((rescaleToUnit({ 2.0, 49.9 }) == std::vector<double>{0.0, 1.0}));, assert((rescaleToUnit({ 100.0, 49.9 }) == std::vector<double>{1.0, 0.0}));, assert((rescaleToUnit({ 1.0, 2.0, 3.0, 4.0, 5.0 }) == std::vector<double>{0.0, 0.25, 0.5, 0.75, 1.0}));, assert((rescaleToUnit({ 2.0, 1.0, 5.0, 3.0, 4.0 }) == std::vector<double>{0.25, 0.0, 1.0, 0.5, 0.75}));]"
997,"    """""" Return length of given string
    >>> strlen('')
    0
    >>> strlen('abc')
    3
    """"""
","```
#include <string>

int strlen(const std::string& str) {
    return str.length();
}
```",998,"[assert(strlen("""") == 0);, assert(strlen(""x"") == 1);, assert(strlen(""asdasnakj"") == 9);]"
1006,"    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    -0.5
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    1.0
    """"""
","```
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <cassert>

double poly(const std::vector<int>& arr, const std::vector<int>& sortedThird) {
    // Implement poly logic here, placeholder return
    return 0.0;
}

std::vector<int> sortThird(const std::vector<int>& vec) {
    // Implement sorting logic if necessary
    return vec; // Returning as-is for now
}

std::vector<int> copyArray(const std::vector<int>& original) {
    return original; // Copy the array (vector)
}```",1007,"[assert(std::fabs(poly({ -10 }, sortThird(copyArray({ -10 })))) < 1e-4);, assert(std::fabs(poly({ -10, -2 }, sortThird(copyArray({ -10, -2 })))) < 1e-4);, assert(std::fabs(poly({ -3 }, sortThird(copyArray({ -3 })))) < 1e-4);, assert(std::fabs(poly({ -3, -6 }, sortThird(copyArray({ -3, -6 })))) < 1e-4);, assert(std::fabs(poly({ -3, -6, -7 }, sortThird(copyArray({ -3, -6, -7 })))) < 1e-4);]"
1016,"    """"""Return list with elements incremented by 1.
    >>> incr_list([1, 2, 3])
    [2, 3, 4]
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    [6, 4, 6, 3, 4, 4, 10, 1, 124]
    """"""
","```
#include <cassert>
#include <vector>

std::vector<int> incr_list(const std::vector<int>& lst) {
    std::vector<int> result;
    for (int num : lst) {
        result.push_back(num + 1);
    }
    return result;
}```",1017,"[assert(incr_list({}) == std::vector<int>{});, assert((incr_list({ 3, 2, 1 }) == std::vector<int>{4, 3, 2}));, assert((incr_list({ 5, 2, 5, 2, 3, 3, 9, 0, 123 }) == std::vector<int>{6, 3, 6, 3, 4, 4, 10, 1, 124}));]"
1021,"    """"""Return median of elements in the list l.
    >>> median([3, 1, 2, 4, 5])
    3
    >>> median([-10, 4, 6, 1000, 10, 20])
    15.0
    """"""
","```
#include <cassert>
#include <vector>
#include <algorithm>

double median(std::vector<int> nums) {
    std::sort(nums.begin(), nums.end());
    size_t size = nums.size();
    if (size % 2 == 0) {
        return (nums[size / 2 - 1] + nums[size / 2]) / 2.0;
    }
    else {
        return nums[size / 2];
    }
}```",1022,"[assert(median({3, 1, 2, 4, 5}) == 3);, assert(median({-10, 4, 6, 1000, 10, 20}) == 8.0);, assert(median({5}) == 5);, assert(median({6, 5}) == 5.5);, assert(median({8, 1, 3, 9, 9, 2, 7}) == 7);]"
1043,"    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","```
#include <iostream>
#include <vector>
#include <algorithm>
#include <cassert>

int search(const std::vector<int>& lst) {
    if (lst.empty()) return -1;

    int maxVal = *std::max_element(lst.begin(), lst.end());
    std::vector<int> frq(maxVal + 1, 0);

    for (int val : lst) {
        frq[val]++;
    }

    int ans = -1;
    for (size_t i = 1; i < frq.size(); i++) {
        if (frq[i] >= static_cast<int>(i)) {
            ans = i;
        }
    }

    return ans;
}```",1044,"[assert(search({ 5, 5, 5, 5, 1 }) == 1);, assert(search({ 4, 1, 4, 1, 4, 4 }) == 4);, assert(search({ 3, 3 }) == -1);, assert(search({ 8, 8, 8, 8, 8, 8, 8, 8 }) == 8);]"
1044,"    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","```
#include <vector>
#include <algorithm>

std::vector<int> strange_sort_list(std::vector<int> lst) {
    std::vector<int> res;
    bool switch_flag = true;
    while (!lst.empty()) {
        if (switch_flag) {
            auto min_it = std::min_element(lst.begin(), lst.end());
            res.push_back(*min_it);
            lst.erase(min_it);
        }
        else {
            auto max_it = std::max_element(lst.begin(), lst.end());
            res.push_back(*max_it);
            lst.erase(max_it);
        }
        switch_flag = !switch_flag;
    }
    return res;
}```",1045,"[assert((strange_sort_list({ 1, 2, 3, 4 }) == std::vector<int>{1, 4, 2, 3}));, assert((strange_sort_list({ 5, 6, 7, 8, 9 }) == std::vector<int>{5, 9, 6, 8, 7}));, assert(( strange_sort_list({ 1, 2, 3, 4, 5 }) == std::vector<int>{1, 5, 2, 4, 3}));]"
1070,"    """"""Implement a function that takes an non-negative integer and returns an array of the first n
    integers that are prime numbers and less than n.
    for example:
    count_up_to(5) => [2,3]
    count_up_to(11) => [2,3,5,7]
    count_up_to(0) => []
    count_up_to(20) => [2,3,5,7,11,13,17,19]
    count_up_to(1) => []
    count_up_to(18) => [2,3,5,7,11,13,17]
    """"""
","```
#include <vector>

std::vector<int> count_up_to(int n) {
    std::vector<int> primes;
    for (int i = 2; i < n; i++) {
        bool is_prime = true;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            primes.push_back(i);
        }
    }
    return primes;
}
```",1071,"[assert((count_up_to(5) == std::vector<int>{2, 3}));, assert((count_up_to(6) == std::vector<int>{2, 3, 5}));, assert((count_up_to(7) == std::vector<int>{2, 3, 5}));]"
1112,"    """"""Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers
    Example
    is_equal_to_sum_even(4) == False
    is_equal_to_sum_even(6) == False
    is_equal_to_sum_even(8) == True
    """"""
","```
bool is_equal_to_sum_even(int n) {
    return n % 2 == 0 && n >= 8;
}
```",1113,"[assert(is_equal_to_sum_even(4) == false);, assert(is_equal_to_sum_even(6) == false);, assert(is_equal_to_sum_even(8) == true);]"
1114,"    """"""
    Given a string text, replace all spaces in it with underscores, 
    and if a string has more than 2 consecutive spaces, 
    then replace all consecutive spaces with - 
    
    fix_spaces(""Example"") == ""Example""
    fix_spaces(""Example 1"") == ""Example_1""
    fix_spaces("" Example 2"") == ""_Example_2""
    fix_spaces("" Example   3"") == ""_Example-3""
    """"""
","```
#include <string>

std::string fix_spaces(const std::string& text) {
    std::string new_text = """";
    size_t i = 0;
    size_t start = 0, end = 0;
    
    while (i < text.length()) {
        if (text[i] == ' ') {
            end++;
        } else {
            if (end - start > 2) {
                new_text += ""-"" + std::string(1, text[i]);
            } else if (end - start > 0) {
                new_text += std::string(end - start, '_') + text[i];
            } else {
                new_text += text[i];
            }
            start = i + 1;
            end = i + 1;
        }
        i++;
    }
    
    if (end - start > 2) {
        new_text += ""-"";
    } else if (end - start > 0) {
        new_text += ""_"";
    }
    
    return new_text;
}
```",1115,"[assert(fix_spaces(""Example"") == ""Example"" && ""This prints if this assert fails 1 (good for debugging!)"");, assert(fix_spaces(""Mudasir Hanif "") == ""Mudasir_Hanif_"" && ""This prints if this assert fails 2 (good for debugging!)"");, assert(fix_spaces(""Yellow Yellow  Dirty  Fellow"") == ""Yellow_Yellow__Dirty__Fellow"" && ""This prints if this assert fails 3 (good for debugging!)"");]"
1122,"    '''
    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    This is  a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    Examples
    bf(""Jupiter"", ""Neptune"") ==> (""Saturn"", ""Uranus"")
    bf(""Earth"", ""Mercury"") ==> (""Venus"")
    bf(""Mercury"", ""Uranus"") ==> (""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn"")
    '''
","```
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cassert>

class Planet {
public:
    static std::vector<std::string> bf(const std::string& planet1, const std::string& planet2) {
        std::vector<std::string> planetNames = {
            ""Mercury"", ""Venus"", ""Earth"", ""Mars"", 
            ""Jupiter"", ""Saturn"", ""Uranus"", ""Neptune""
        };

        // Check if both planets are valid and not the same
        if (std::find(planetNames.begin(), planetNames.end(), planet1) == planetNames.end() ||
            std::find(planetNames.begin(), planetNames.end(), planet2) == planetNames.end() ||
            planet1 == planet2) {
            return {}; // Return an empty vector
        }

        int planet1Index = std::distance(planetNames.begin(), std::find(planetNames.begin(), planetNames.end(), planet1));
        int planet2Index = std::distance(planetNames.begin(), std::find(planetNames.begin(), planetNames.end(), planet2));

        if (planet1Index < planet2Index) {
            return std::vector<std::string>(planetNames.begin() + planet1Index + 1, planetNames.begin() + planet2Index);
        } else {
            return std::vector<std::string>(planetNames.begin() + planet2Index + 1, planetNames.begin() + planet1Index);
        }
    }
};```",1123,"[assert((Planet::bf(""Jupiter"", ""Neptune"") == std::vector<std::string>{""Saturn"", ""Uranus""}) && ""First test failed"");, assert((Planet::bf(""Earth"", ""Mercury"") == std::vector<std::string>{""Venus""}) && ""Second test failed"");, assert((Planet::bf(""Mercury"", ""Uranus"") == std::vector<std::string>{""Venus"", ""Earth"", ""Mars"", ""Jupiter"", ""Saturn""}) && ""Third test failed"");, assert((Planet::bf(""Neptune"", ""Venus"") == std::vector<std::string>{""Earth"", ""Mars"", ""Jupiter"", ""Saturn"", ""Uranus""}) && ""Fourth test failed"");, assert((Planet::bf(""Earth"", ""Earth"").empty()) && ""Fifth test failed"");, assert((Planet::bf(""Mars"", ""Earth"").empty()) && ""Sixth test failed"");, assert((Planet::bf(""Jupiter"", ""Makemake"").empty()) && ""Seventh test failed"");]"
1124,"    """"""A simple program which should return the value of x if n is 
    a prime number and should return the value of y otherwise.

    Examples:
    for x_or_y(7, 34, 12) == 34
    for x_or_y(15, 8, 5) == 5
    
    """"""
","```
int x_or_y(int n, int x, int y) {
    if (n == 1) {
        return y;
    }
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            return y;
            break;
        }
    }
    return x;
}
```",1125,"[assert(x_or_y(7, 34, 12) == 34);, assert(x_or_y(15, 8, 5) == 5);, assert(x_or_y(3, 33, 5212) == 33);]"
1137,"    """"""
    Given two positive integers a and b, return the even digits between a
    and b, in ascending order.

    For example:
    generate_integers(2, 8) => [2, 4, 6, 8]
    generate_integers(8, 2) => [2, 4, 6, 8]
    generate_integers(10, 14) => []
    """"""
","```
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> generateIntegers(int a, int b) {
    int lower = std::max(2, std::min(a, b));
    int upper = std::min(8, std::max(a, b));
    std::vector<int> result;

    for (int i = lower; i <= upper; i++) {
        if (i % 2 == 0) {
            result.push_back(i);
        }
    }
    return result;
}```",1138,"[assert((generateIntegers(2, 10) == std::vector<int>{2, 4, 6, 8}));, assert((generateIntegers(10, 1) == std::vector<int>{2, 4, 6, 8}) && ""Test 2 failed"");]"
